<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://microsoft.github.io/coyote/tutorials/tasks/first-concurrency-unit-test/">
    <link rel="shortcut icon" href="/coyote/img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Write your first concurrency unit test - Coyote</title>
    <link href="/coyote/css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="/coyote/css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="/coyote/css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="/coyote/css/highlight.css">
    <link href="../../../css/main.css" rel="stylesheet">
    <link href="../../../css/player-controls.css" rel="stylesheet">
    <link href="../../../css/syntax.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="/coyote/js/jquery-3.2.1.min.js"></script>
    <script src="/coyote/js/bootstrap-3.3.7.min.js"></script>
    <script src="/coyote/js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '/coyote/';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Write your first concurrency unit test with Coyote", url: "#_top", children: [
          ]},
          {title: "What you will need", url: "#what-you-will-need", children: [
          ]},
          {title: "Walkthrough", url: "#walkthrough", children: [
          ]},
          {title: "Get the sample source code", url: "#get-the-sample-source-code", children: [
          ]},
        ];

    </script>
    <script src="/coyote/js/base.js"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=UA-89203408-1"></script>
      <script src="https://consentdeliveryfd.azurefd.net/mscc/lib/v2/wcp-consent.js"></script>
      <script src="../../../assets/js/analytics.js"></script>
      <script src="../../../assets/js/plugins.js"></script>
      <script src="../../../assets/js/animate_trace.js"></script>
      <script src="../../../assets/js/animation.js"></script>
      <script src="../../../assets/js/progress_bar.js"></script>
      <script src="../../../assets/js/trace_model.js"></script>
      <script src="../../../assets/js/main.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>

<div id="cookie-banner"></div>


<div class="wrapper wm-page-content">
  <div class="container-fluid">
    <a name="_top"></a>
      

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../test-concurrent-operations/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../test-concurrent-operations/" class="btn btn-xs btn-link">
        Test concurrent CRUD operations
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../../programming-models/actors/why-actors/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../../programming-models/actors/why-actors/" class="btn btn-xs btn-link">
        Why Coyote actors?
      </a>
    </div>
    
  </div>

      

      <h2 id="write-your-first-concurrency-unit-test-with-coyote">Write your first concurrency unit test with Coyote</h2>
<p>Modern software systems are inherently concurrent in nature as they perform many different
activities at the same time, across different threads, processes and machines. Concurrency is
notoriously hard to test, and concurrent bugs can be hard to reproduce and understand. Coyote is a
very effective tool in taming this complexity. By giving you the ability to easily test for
concurrency bugs, Coyote helps you build more reliable applications and services.</p>
<p>In this tutorial, we will write a simple <code>AccountManager</code> class to create, get and delete <em>account</em>
records in a backend NoSQL database. We&rsquo;ll design our class to be used in a concurrent setting,
where methods in multiple instances of the class can be called concurrently, either within the same
process or across processes and machines. This latter condition means that using locks will not help
us in writing correct concurrent code.</p>
<h2 id="what-you-will-need">What you will need</h2>
<p>To run the <code>AccountManager</code> example, you will need to:</p>
<ul>
<li>Install <a href="https://visualstudio.microsoft.com/downloads/">Visual Studio 2019</a>.</li>
<li>Install the <a href="../../../get-started/install/">.NET 5.0 version of the coyote tool</a>.</li>
<li>Be familiar with the <code>coyote test</code> tool. See <a href="../../../tools/testing/">Testing</a>.</li>
<li>Be familiar with the <code>coyote rewrite</code> tool. See <a href="../../../tools/rewriting/">Rewriting</a>.</li>
</ul>
<h2 id="walkthrough">Walkthrough</h2>
<p>Without further ado, let&rsquo;s look at the signature of the <code>AccountManager</code> class:</p>
<pre><code class="language-c#">public class AccountManager
{
  private IDbCollection AccountCollection;

  // Returns true if the account is created, else false.
  public async Task&lt;bool&gt; CreateAccount(string accountName, string accountPayload) { ... }

  // Returns the accountPayload, else null.
  public async Task&lt;string&gt; GetAccount(string accountName) { ... }

  // Returns true if the account is deleted, else false.
  public async Task&lt;bool&gt; DeleteAccount(string accountName) { ... }
}
</code></pre>
<p>Here are the methods available in the <code>IDbCollection</code> interface:</p>
<pre><code class="language-c#">public interface IDbCollection
{
  Task CreateRow(string key, string value);

  Task&lt;bool&gt; DoesRowExist(string key);

  Task&lt;string&gt; GetRow(string key);

  Task DeleteRow(string key);
}
</code></pre>
<p>The <code>CreateRow</code> method creates the row with the given key, unless it already exists in which case it
returns the <code>RowAlreadyExistsException</code> exception. The <code>DoesRowExist</code> method returns <code>true</code> if the
row exists, otherwise it returns <code>false</code>. The <code>GetRow</code> method returns the content of the given key
and throws <code>RowNotFoundException</code> exception if it doesn&rsquo;t exist. Finally, the <code>DeleteRow</code> method
deletes the row if it exists and throws <code>RowNotFoundException</code> exception if it doesn&rsquo;t exist.</p>
<p>Before reading on, we encourage you to open your editor and attempt to write out the code.</p>
<p>Here&rsquo;s one attempt to implement the <code>AccountManager</code> class:</p>
<pre><code class="language-c#">public class AccountManager
{
  private readonly IDbCollection AccountCollection;

  public AccountManager(IDbCollection dbCollection)
  {
    this.AccountCollection = dbCollection;
  }

  // Returns true if the account is created, else false.
  public async Task&lt;bool&gt; CreateAccount(string accountName, string accountPayload)
  {
    if (await this.AccountCollection.DoesRowExist(accountName))
    {
      return false;
    }

    await this.AccountCollection.CreateRow(accountName, accountPayload);
    return true;
  }

  // Returns the accountPayload, else null.
  public async Task&lt;string&gt; GetAccount(string accountName)
  {
    if (!await this.AccountCollection.DoesRowExist(accountName))
    {
      return null;
    }

    return await this.AccountCollection.GetRow(accountName);
  }

  // Returns true if the account is deleted, else false.
  public async Task&lt;bool&gt; DeleteAccount(string accountName)
  {
    if (!await this.AccountCollection.DoesRowExist(accountName))
    {
      return false;
    }

    await this.AccountCollection.DeleteRow(accountName);
    return true;
  }
}
</code></pre>
<p>Does the above implementation look reasonable to you? Can you find any bugs? And how can you
convince yourself of the absence of any bugs in the above program?</p>
<p>Let&rsquo;s write a unit test to test the <code>AccountManager</code> code. In production, <code>IDbCollection</code> is
implemented using a distributed NoSQL database. To keep things simple during testing, we can just
replace it with a mock. The following code shows such a mock implementation:</p>
<pre><code class="language-c#">public class InMemoryDbCollection : IDbCollection
{
  private readonly ConcurrentDictionary&lt;string, string&gt; Collection;

  public InMemoryDbCollection()
  {
    this.Collection = new ConcurrentDictionary&lt;string, string&gt;();
  }

  public Task CreateRow(string key, string value)
  {
    return Task.Run(() =&gt;
    {
      var result = this.Collection.TryAdd(key, value);
      if (!result)
      {
        throw new RowAlreadyExistsException();
      }
    });
  }

  public Task DeleteRow(string key)
  {
    return Task.Run(() =&gt;
    {
      var removed = this.Collection.TryRemove(key, out string value);
      if (!removed)
      {
        throw new RowNotFoundException();
      }
    });
  }

  public Task&lt;bool&gt; DoesRowExist(string key)
  {
    return Task.Run(() =&gt;
    {
      return this.Collection.ContainsKey(key);
    });
  }

  public Task&lt;string&gt; GetRow(string key)
  {
    return Task.Run(() =&gt;
    {
      var result = this.Collection.TryGetValue(key, out string value);
      if (!result)
      {
        throw new RowNotFoundException();
      }
      return value;
    });
  }
}
</code></pre>
<p>The <code>InMemoryDbCollection</code> mock is very simple, it just maintains an in-memory
<code>ConcurrentDictionary</code> to store the keys and values. Each method of the mock runs a new concurrent
task (via <code>Task.Run</code>) to make the call execute asynchronously, modeling async I/O in a real database
call.</p>
<p>Now that we have written this mock, lets write a simple test:</p>
<pre><code class="language-c#">[Test]
public static async Task TestAccountCreation()
{
  // Initialize the mock in-memory DB and account manager.
  var dbCollection = new InMemoryDbCollection();
  var accountManager = new AccountManager(dbCollection);

  // Create some dummy data.
  string accountName = &quot;MyAccount&quot;;
  string accountPayload = &quot;...&quot;;

  // Create the account, it should complete successfully and return true.
  var result = await accountManager.CreateAccount(accountName, accountPayload);
  Assert.True(result);

  // Create the same account again. The method should return false this time.
  result = await accountManager.CreateAccount(accountName, accountPayload);
  Assert.False(result);
}
</code></pre>
<p>The above unit test clearly tests that the same account cannot be created twice. Try run it (check
below for instructions on how to build and run this tutorial from our samples repository) and you
will see that it always passes. But is the behavior still true if two requests happen
<em>concurrently</em>? How can we test this?</p>
<p>Hmm - what if we spawn two tasks to create the same account, concurrently? And then assert that only
one creation succeeds, while the other always fails? That can possibly work, right? Let&rsquo;s write this
test.</p>
<pre><code class="language-c#">[Test]
public static async Task TestConcurrentAccountCreation()
{
  // Initialize the mock in-memory DB and account manager.
  var dbCollection = new InMemoryDbCollection();
  var accountManager = new AccountManager(dbCollection);

  // Create some dummy data.
  string accountName = &quot;MyAccount&quot;;
  string accountPayload = &quot;...&quot;;

  // Call CreateAccount twice without awaiting, which makes both methods run
  // asynchronously with each other.
  var task1 = accountManager.CreateAccount(accountName, accountPayload);
  var task2 = accountManager.CreateAccount(accountName, accountPayload);

  // Then wait both requests to complete.
  await Task.WhenAll(task1, task2);

  // Finally, assert that only one of the two requests succeeded and the other
  // failed. Note that we do not know which one of the two succeeded as the
  // requests ran concurrently (this is why we use an exclusive OR).
  Assert.True(task1.Result ^ task2.Result);
}
</code></pre>
<p>Try run this concurrent test. The assertion will <em>most likely</em> fail. The reason we say most likely
instead of a guaranteed failure is that there are some task interleavings where it passes, and
others where it fails with the following exception:</p>
<pre><code class="language-plain">Unhandled exception. RowAlreadyExistsException: Exception of type 'RowAlreadyExistsException' was thrown.
...
</code></pre>
<p>Let&rsquo;s dig into why the concurrent test failed.</p>
<p>We started two asynchronous <code>CreateAccount</code> calls, the first one checked whether the user existed
through the <code>DoesRowExist</code> method which returned <code>false</code>. Due to the underlying concurrency, control
passed to the second task which made a similar call to <code>DoesRowExist</code> which also returned <code>false</code>.
Both tasks then resumed believing that the account does not exist and tried to add the account. One
of them succeeded while the other threw an exception, indicating a bug in our implementation.</p>
<p>So writing out this test was useful and easily exposed this race condition. But why don&rsquo;t we
write such tests a lot more often? The reason is they are often flaky and find bugs through <em>sheer
luck</em> instead of a <em>systematic</em> exploration of the possible interleavings. The above test hits the bug
fairly frequently due to the way .NET task scheduling works (on a reasonably fast machine with light
CPU load).</p>
<p>Let&rsquo;s tweak the test very slightly by adding a delay of a millisecond between the two <code>CreateAccount</code>
calls:</p>
<pre><code class="language-c#">var task1 = accountManager.CreateAccount(accountName, accountPayload);
await Task.Delay(1); // Artificial delay.
var task2 = accountManager.CreateAccount(accountName, accountPayload);
</code></pre>
<p>If you run this test, chances are it will fail exceedingly rarely. We ran this test in a loop
invoking it about a hundred times and it didn&rsquo;t fail once.</p>
<pre><code class="language-plain">Iteration 0 - Passed
Iteration 1 - Passed
...
Iteration 99 - Passed
</code></pre>
<p>The race condition is still there but our concurrency unit test suddenly became ineffective at
catching it. This explains why developers don&rsquo;t write such tests as they are very sensitive to
timing issues. Instead, developers often write <em>stress</em> tests, where the system is bombarded with
thousands of concurrent requests in the hopes that some rare interleaving would expose these kind of
nondeterministic bugs (known as <a href="https://en.wikipedia.org/wiki/Heisenbug">Heizenbugs</a>) before the
code is deployed in production. But stress testing can be complex to setup and it doesn&rsquo;t always
find the most tricky bugs. Even if it did, it might produce such long traces (or logs) that might
make it very time consuming to debug and fix.</p>
<p>The above is clearly not a satisfactory solution. What we need is a tool which can systematically
explore the various task interleavings in test mode as opposed to leaving that to luck (i.e. the
operating system scheduler). Coyote gives you <em>exactly</em> this.</p>
<p>To use Coyote on your task-based program is very easy in most cases. All you need to do is to invoke
the <code>coyote rewrite</code> tool which <a href="../../../tools/rewriting/">rewrites</a> your assembly (for testing only)
so that Coyote can inject logic that allows it to take control of the schedule of C# tasks. Then,
you can invoke the <code>coyote test</code> tool which <a href="../../../core/concurrency-unit-testing/">systematically explores</a>
task interleavings to uncover bug. If a bug is uncovered, Coyote allows you to deterministically
reproduce it every single time.</p>
<p>Let&rsquo;s now run our test under the control of Coyote, <em>without changing a single line of code</em>. First use
Coyote to rewrite the assembly:</p>
<pre><code class="language-plain">coyote rewrite .\AccountManager.dll
. Rewriting AccountManager.dll
... Rewriting the 'AccountManager.dll' assembly
... Writing the modified 'AccountManager.dll' assembly to AccountManager.dll
. Done rewriting in 0.6425808 sec
</code></pre>
<p>Awesome, now lets try use Coyote on the above concurrent test:</p>
<pre><code class="language-plain">coyote test .\AccountManager.dll -m TestConcurrentAccountCreation -i 100
</code></pre>
<p>The above command tells Coyote to execute the test method <code>TestConcurrentAccountCreation</code> for 100
iterations. Each iteration will try explore different interleavings to try unearth the bug. You can
read more about other Coyote tool options <a href="../../../tools/testing/">here</a>.</p>
<p>Let&rsquo;s see if Coyote finds the bug now that the concurrent program execution is under its control.
Indeed after just 4 iterations and 0.22 seconds:</p>
<pre><code class="language-plain">. Testing .\AccountManager.dll
... Method TestConcurrentAccountCreation
... Started the testing task scheduler (process:61212).
... Created '1' testing task (process:61212).
... Task 0 is using 'random' strategy (seed:2183365473).
..... Iteration #1
..... Iteration #2
..... Iteration #3
..... Iteration #4
... Task 0 found a bug.
... Emitting task 0 traces:
..... Writing AccountManager_0_0.txt
..... Writing AccountManager_0_0.schedule
... Elapsed 0.092809 sec.
... Testing statistics:
..... Found 1 bug.
... Scheduling statistics:
..... Explored 4 schedules: 4 fair and 0 unfair.
..... Found 25.00% buggy schedules.
..... Number of scheduling points in fair terminating schedules: 8 (min), 11 (avg), 14 (max).
... Elapsed 0.2256287 sec.
</code></pre>
<p>Cool, we found the bug! Let&rsquo;s see now how Coyote can help us reproduce it. You can simple run
<code>coyote replay</code> giving the <code>.schedule</code> file that Coyote dumps upon finding a bug:</p>
<pre><code class="language-plain">coyote replay .\AccountManager.dll -schedule AccountManager_0_0.schedule -m TestConcurrentAccountCreation
. Replaying .\Output\AccountManager.dll\CoyoteOutput\AccountManager_0_1.schedule
... Task 0 is using 'replay' strategy.
... Reproduced 1 bug (use --break to attach the debugger).
... Elapsed 0.0671654 sec.
</code></pre>
<p>Nice, the bug was reproduced. You can even use the <code>--break</code> option to attach the VS debugger and
happily debug the deterministic trace to figure out what is causing the bug. You can repeat this as
many times as you want!</p>
<p>In this tutorial, we saw that we were able to use Coyote to reliably reproduce the race condition in
<code>AccountManager</code>. We did this with a tiny test (just two <code>CreateAccount</code> calls racing with each
other), as opposed to overloading the system with thousands of concurrent tasks through stress
testing.</p>
<p>This of course was a simple example, but it&rsquo;s easy to imagine the many non-trivial concurrency bugs
in a much more complex codebase. Such bugs have very low probability of being caught during test
time, if you don&rsquo;t use a tool like Coyote to systematically explore the interleavings. In the
absence of such tools, these bugs can go undetected and occur sporadically in production, making
them difficult to diagnose and debug. And who wants to stay awake at night debugging a live site!</p>
<p>In the <a href="../test-concurrent-operations/">next tutorial</a>, we will write few more concurrency unit tests
for the <code>AccountManager</code> to increase our familiarity with Coyote.</p>
<h2 id="get-the-sample-source-code">Get the sample source code</h2>
<p>To get the complete source code for the <code>AccountManager</code> tutorial, clone the
<a href="http://github.com/microsoft/coyote-samples">Coyote Samples git repo</a>.
Note that the repo also contains the code from the <a href="../test-concurrent-operations/">next tutorial</a> which
builds upon this <code>AccountManager</code> sample.</p>
<p>You can build the sample by running the following command:</p>
<pre><code class="language-plain">powershell -f build.ps1
</code></pre>
<p>You can now run the tests (without Coyote) like this:</p>
<pre><code class="language-plain">cd .\bin\net5.0
.\AccountManager.exe
</code></pre>
<p>We have added some command line arguments to make it easy select which test to run:</p>
<pre><code class="language-plain">Usage: AccountManager [option]
Options:
  -s    Run sequential test without Coyote
  -c    Run concurrent test without Coyote
</code></pre>
<p>To rewrite and test the sample with Coyote you can use the following commands (as discussed above):</p>
<pre><code class="language-plain">coyote rewrite .\AccountManager.dll
coyote test .\AccountManager.dll -m TestConcurrentAccountCreation -i 100
</code></pre>
<p>If you find a bug you can replay with the following command:</p>
<pre><code class="language-plain">coyote replay .\AccountManager.dll -schedule AccountManager_0_0.schedule -m TestConcurrentAccountCreation
</code></pre>
<p>Enjoy!</p>

    <br>
      

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../test-concurrent-operations/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../test-concurrent-operations/" class="btn btn-xs btn-link">
        Test concurrent CRUD operations
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../../programming-models/actors/why-actors/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../../programming-models/actors/why-actors/" class="btn btn-xs btn-link">
        Why Coyote actors?
      </a>
    </div>
    
  </div>

      <br>
  </div>
</div>

<footer class="wm-page-content">
      <p>
        <a href="https://github.com/microsoft/coyote/"><i class="fa fa-github"></i>
GitHub</a>
      </p>

  

<section class="footer-join pt-40 pb-80">
  <div class="container-fluid">
    <div class="row text-center">
      <div class="col-sm-8 col-sm-offset-2">
      </div>
    </div>
    <div class="row">

   </div>
  </div>
</section>
<section class="footer-dark pt-60">
  <div class="container-fluid">
    <div class="row">
      <div class="hidden-xs col-sm-5 col-lg-6">
        <a href="" title="homepage" class="logo-footer">
          <img src="/coyote/assets/images/icon.png" alt="Coyote">
        </a>
      </div>

      <div class="col-sm-2 col-xs-4 footer-dark-col">
        <nav>
          <h4>Coyote</h4>
          <ul class="list-unstyled">

            <li><a href="/coyote/">Home</a></li>

            <li><a href="/coyote/overview/about">About</a></li>

          </ul>
        </nav>
      </div>

      <div class="col-sm-2 col-xs-4 footer-dark-col">
        <nav>
          <h4>Resources</h4>
          <ul class="list-unstyled">

            <li><a href="/coyote/get-started/install">Install</a></li>

            <li><a href="/coyote/get-started/using-coyote">Getting started</a></li>

          </ul>
        </nav>
      </div>

      <div class="col-sm-2 col-xs-4 footer-dark-col">
        <nav>
          <h4>Community</h4>
          <ul class="list-unstyled">

            <li><a href="https://github.com/microsoft/coyote" target="_blank">GitHub</a></li>

            <li><a href="https://gitter.im/microsoft/coyote" target="_blank">Gitter</a></li>

          </ul>
        </nav>
      </div>

    </div>

    <div class="row footnote pt-50 pb-20">
      <div class="col-sm-12">
        <hr>
      </div>
      <div class="col-sm-6">
        <ul class="list-unstyled list-inline footnote-copy">

          <li><a href="https://privacy.microsoft.com/en-us/privacystatement/" target="_blank">Privacy</a></li>

          <li><a href="https://www.microsoft.com/en-us/legal/intellectualproperty/copyright/default.aspx" target="_blank">Terms of Use</a></li>

          <li><a href="https://github.com/microsoft/coyote/blob/main/LICENSE" target="_blank">License</a></li>

          <li><a href="javascript:manageCookies()">Cookies</a></li>

        </ul>
      </div>
      <div class="col-sm-6 text-right footnote-copy">
        <ul class="list-unstyled list-inline">
          <li><span id="copyright"></span></li>
          <li><a href="https://www.microsoft.com/" target="_blank"><img class="img-responsive" src="/coyote/assets/images/microsoft-logo.svg?v=3" alt="Microsoft">&nbsp;</a></li>
        </ul>
      </div>
    </div>
  </div>
</section>
</footer>


<script type="text/javascript">
    $(document).ready(function () {
      $('table').each(function () {
        $(this).addClass("table");
        $(this).addClass("table-bordered");
        $(this).addClass("table-striped");
        $(this).addClass("table-condensed");
      });

    });
</script>

</body>
</html>